Sigma Block
-----------

A multiply and accumulate using sides A and B multiplied (and optionally scaled by division by 16) and the IN added.
The result is the output modulo 16. No consideration for carries between Sigma blocks is allowed in this design.
The scaling is to simulate very low precision fixed point functionality. A modulo 16 additive inverse may be
subtracted hence keeping the carries out of it as external redstone signals. This also might prepare the user for
some technology production in the real world where carries lead to bottlenecks in OoO execution of machine instructions.
It also has some useful logic limit (0 or 15) forms which can be dropped by the additive inverse method.

Delta Block
-----------

A simple calculus block. I say simple but actually quite complex in implementation, but simpler to use.
The output is the following including a range scaling:
    OUT = k.(d[A - IN] * [B - IN])/dt + IN
The second mode is an integration like operation also based about IN, and the multiply before application.
An endpoint integral with the time set to an appropriate constant. Both these operators contain memory and have
complex behaviour. The also should both produce a static out value of IN when A and B do not change.

Upsilon Block
-------------

A 15 bit clocked ring. 5 redstone cycles per block. High bit is active high clock in first of 5. Lower 3 bits times
five is block. On next clock data bits are valid. Torch off is data set mode. If A = B, then bit set with option 0 being
set clock if 6th IN has no set clock bit. 1 to 15 set appropriate bit in packet OUT from IN. Torch on is data read
mode. If data decode from IN is valid, and bit numbers A and B are both valid true, then output 15, else 0.
Using this kind of select allows for 210 up to selectors. A status farm mux perhaps? Select division, wait for poll.
Bit zero on data read is clock valid. Different A and B in data set mode makes a slave set node which does not set an
unset clock. The allows a bus free if data set mode needs a clock to set bit. Multi packet clocks are data invalidate.
Data OUT is held until next valid decode or A or B change. As a convenience OUT is one less for quick inserts.

Pi Block
--------

Equality synchronous RAM. If A = B, location IN gets written with AB, and/or else read location IN to OUT. This makes
for easy read write control by interception of either A or B. It provides a massive 16 nibbles of memory and decode.
With care some of the RAM is FLASH. Disconnection makes A = B = 0, and can zero the addressed location.
So as torch on mode it allow torch off, collect and name in an anvil?
When set in the torch off mode, a nice equality inverter is made. This gives a full:
    OUT = (15 - IN) * (A = B) + IN * (A != B)
Long chains just alternate and alternate drive so don't lose signal.